# HG changeset patch
# User Matti Picus <matti.picus@gmail.com>
# Date 1691873583 -10800
#      Sat Aug 12 23:53:03 2023 +0300
# Branch conda-3.9-v7.3.12
# Node ID f160114383d06721f8231e5e9b0ec5a147867816
# Parent  7a1d0ec8c2b0c1dba4cfa57fb98065e960321d23
fixes on both app-level and C level for Py_TPFLAGS_BASETYPE=0 (issue 2742)

diff -r 7a1d0ec8c2b0 -r f160114383d0 pypy/module/cpyext/typeobject.py
--- a/pypy/module/cpyext/typeobject.py	Sat Aug 12 23:50:17 2023 +0300
+++ b/pypy/module/cpyext/typeobject.py	Sat Aug 12 23:53:03 2023 +0300
@@ -20,7 +20,7 @@
     Py_TPFLAGS_TUPLE_SUBCLASS, Py_TPFLAGS_UNICODE_SUBCLASS,
     Py_TPFLAGS_DICT_SUBCLASS, Py_TPFLAGS_BASE_EXC_SUBCLASS,
     Py_TPFLAGS_TYPE_SUBCLASS,
-    Py_TPFLAGS_BYTES_SUBCLASS,
+    Py_TPFLAGS_BYTES_SUBCLASS, Py_TPFLAGS_BASETYPE,
     Py_TPPYPYFLAGS_FLOAT_SUBCLASS,
     )
 
@@ -613,11 +613,11 @@
         else:
             minsize = rffi.sizeof(PyObject.TO)
         new_layout = (pto.c_tp_basicsize > minsize or pto.c_tp_itemsize > 0)
-
         self.flag_cpytype = True
         W_TypeObject.__init__(self, space, name,
             bases_w or [space.w_object], dict_w, force_new_layout=new_layout,
             is_heaptype=flag_heaptype)
+
         # if a sequence or a mapping, then set the flag to force it
         if pto.c_tp_as_sequence and pto.c_tp_as_sequence.c_sq_item:
             self.flag_map_or_seq = 'S'
@@ -632,6 +632,15 @@
         self._cpy_ref = py_obj
         rawrefcount.create_link_pyobj(self, py_obj)
 
+    def acceptable_as_base_class(self, space):
+        if not self.layout.typedef.acceptable_as_base_class:
+            return False
+        pyref = make_ref(space, self)
+        pto = rffi.cast(PyTypeObjectPtr, pyref)
+        acceptable_as_base_class = bool(widen(pto.c_tp_flags) & Py_TPFLAGS_BASETYPE)
+        decref(space, pyref)
+        return acceptable_as_base_class
+
 @bootstrap_function
 def init_typeobject(space):
     make_typedescr(space.w_type.layout.typedef,
@@ -707,6 +716,8 @@
     pto.c_tp_free = state.C.PyObject_Free
     pto.c_tp_alloc = state.C.PyType_GenericAlloc
     builder = state.builder
+    if w_type.layout.typedef.acceptable_as_base_class:
+        pto.c_tp_flags = rffi.cast(rffi.ULONG, widen(pto.c_tp_flags) | Py_TPFLAGS_BASETYPE)
     if ((widen(pto.c_tp_flags) & Py_TPFLAGS_HEAPTYPE) != 0
             and builder.cpyext_type_init is None):
             # this ^^^ is not None only during startup of cpyext.  At that
@@ -983,12 +994,12 @@
     PyType_FromSpecWithBases(PyType_Spec *spec, PyObject *bases)""",
     result_is_ll=True)
 def PyType_FromSpecWithBases(space, spec, bases):
-    return PyType_FromSpecWithBases(space, None, spec, bases)
+    return PyType_FromModuleAndSpec(space, None, spec, bases)
 
 @cts.decl("""PyObject *
-    PyType_FromModuleAndSpec(PyObject *, PyType_Spec *spec, PyObject *bases)""",
+    PyType_FromModuleAndSpec(PyObject *module, PyType_Spec *spec, PyObject *bases)""",
     result_is_ll=True)
-def PyType_FromSpecWithBases(space, module, spec, bases):
+def PyType_FromModuleAndSpec(space, module, spec, bases):
     from pypy.module.cpyext.unicodeobject import PyUnicode_FromString
     state = space.fromcache(State)
     p_type = cts.cast('PyTypeObject*', make_ref(space, space.w_type))
@@ -1033,10 +1044,10 @@
         bases_w = space.fixedview(from_ref(space, bases))
     w_base = best_base(space, bases_w)
     base = cts.cast('PyTypeObject*', make_ref(space, w_base))
-    if False:  # not widen(base.c_tp_flags) & Py_TPFLAGS_BASETYPE:
+    if not widen(base.c_tp_flags) & Py_TPFLAGS_BASETYPE:
         raise oefmt(space.w_TypeError,
             "type '%s' is not an acceptable base type",
-            rffi.charp2str(base.c_tp_name))
+            rffi.constcharp2str(base.c_tp_name))
 
     typ.c_tp_as_async = res.c_as_async
     typ.c_tp_as_number = res.c_as_number
diff -r 7a1d0ec8c2b0 -r f160114383d0 pypy/objspace/std/typeobject.py
--- a/pypy/objspace/std/typeobject.py	Sat Aug 12 23:50:17 2023 +0300
+++ b/pypy/objspace/std/typeobject.py	Sat Aug 12 23:53:03 2023 +0300
@@ -769,6 +769,9 @@
         raise oefmt_attribute_error(
             space, self, w_name, "type object '%N' has no attribute %R")
 
+    def acceptable_as_base_class(self, space):
+        # Overridden by cpyext W_PyCTypeObject
+        return self.layout.typedef.acceptable_as_base_class
 
 def descr__new__(space, w_typetype, __args__):
     """This is used to create user-defined classes only."""
@@ -1217,7 +1220,7 @@
     if w_bestbase is None:
         raise oefmt(space.w_TypeError,
                     "a new-style class can't have only classic bases")
-    if not w_bestbase.layout.typedef.acceptable_as_base_class:
+    if not w_bestbase.acceptable_as_base_class(space):
         raise oefmt(space.w_TypeError,
                     "type '%s' is not an acceptable base type", w_bestbase.name)
 
